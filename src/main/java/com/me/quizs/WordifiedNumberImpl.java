package com.me.quizs;

import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

public class WordifiedNumberImpl implements WordifiedNumber {

    /**
     * First of all we declare final instance variables to be used to build number words, format, etc.
     * These data could be stored in static configuration files out of the Java artifact.
     * There are 3 main lists: units, tens and big numbers (thousand and beyond).
     * Values never change.
     */
    //Numbers 0-19
    final static String conjunction = "and";
    final static String hundred = "hundred";
    final static String decimalFormat = "###,###.###";
    final static String separator = ",";
    final static String[] units = {"zero", "one", "two", "three", "four",
        "five", "six", "seven", "eight", "nine", "ten",
        "eleven", "twelve", "thirteen", "fourteen", "fifteen",
        "sixteen", "seventeen", "sighteen", "nineteen"};
    //The position in the collection is important. So, positions 0 (0-9) and 1 (10-19) in the array are empty.
    final static String[] tens = {"", "", "twenty", "thirty", "forty", "fifty",
        "sixty", "seventy", "eighty", "ninety"};

    final static String[] qualifiers = new String[]{"", "thousand", "million", "billion"};
    //And beyond...

    /*
     INTERNATIONALIZATION
     Other languages can be displayed by including locale values.
    
     final static String conjunction = "y";
     final static String hundred = "cien";
     final static String decimalFormat = "###,###.###";
     final static String separator = ".";
     final  static String[] units = {"cero","uno","dos","tres","cuatro",
     "cinco","seis","siete","ocho","nueve","diez",
     "once","doce","trece","catorce","quince",
     "dieciseis","diecisiete","dieciocho","diecinueve"};
     final static String[] tens = {"","","veinte","treinta","cuarenta","cincuenta",
     "sesenta","sesenta","ochenta","noventa"};
     final static String[][] qualifiers = new String[][]{
     { "0",""},
     { "1","mil" },
     { "2","millon" },
     { "3","billon" }
     };
     */
    
    /*
    ORDINALS
    Ordinals can be generated by changing values. For example:
    final static String[] units = {"zero", "first", "second", "third", "fourth",
           "fifth", "sixth", "seventh", "eighth", "ninth", "tenth",
           "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth",
           "sixteenth", "seventeenth", "sighteenth", "nineteenth"};
    etc...
    */
    
    
    
    /**
     * public method to return the formatted number.
     * This method is the implementation of the interface WordifiedNumber. So, 
     * by creating a new instance: WordifiedNumber wn = new WordifiedNumberImpl();
     * the public method can be used. Private methods remain hidden.
     * @param  i  the number to be calculated as a cardinal/ordinal
     * @return    The String with the cardinal/ordinal
     */
    @Override
    public String toWords(int i) {
        String formattedNumber = customFormat(i);
        StringTokenizer st = new StringTokenizer(formattedNumber, separator);
        String[] groups = new String[st.countTokens()];
        StringBuilder sb = new StringBuilder();

        /*
        To improve performance numbers < 1000 are directly provided.
        */
        if (groups.length == 1) {
            return calculate(i);
        } else {
            //Divide the number into groups of three
            String[] result = new String[st.countTokens()];
            int counter = 0;
            while (st.hasMoreTokens()) {
                groups[counter] = st.nextToken();
                counter++;
            }
            List<String> groupsList = Arrays.asList(groups);
            Collections.reverse(groupsList);

            int suffix = 0;
            
            //Find the qualifier (thousand, million, etc) to generate the partial expression
            for (String s : groupsList) {
                //To improve performance a specific thread could be spawned
                /*
                BIG BIG NUMBERS
                To improve performance a specific thread could be spawned in order
                to parallelize calculations.
                */
                String literal = calculate(Integer.parseInt(s));
                if (!literal.equalsIgnoreCase(units[0])) {
                    result[suffix] = literal + " " + qualifiers[suffix];
                } else {
                    result[suffix] = "";
                }

                suffix++;
            }

            List<String> resultList = Arrays.asList(result);
            Collections.reverse(resultList);
            Collections.reverse(groupsList);
            
            int position = 0;
            //WARNING: BRITISH ENGLISH
            //Add conjunctions and empty spaces under certain conditions
            for (String s : resultList) {
                if (resultList.size() > 1 && position != 0 && Integer.parseInt(groupsList.get(position)) < 100 && Integer.parseInt(groupsList.get(position)) > 0) {
                    sb.append(conjunction + " ");
                }
                sb.append(s);
                if (position != resultList.size() && Integer.parseInt(groupsList.get(position)) > 0) {
                    sb.append(" ");
                }

                position++;
            }
        }
        System.out.println("RESULT: " + sb);
        return sb.toString().trim();
    }

    /**
     * private method to return the formatted number.
     * The calculation of literals method is based on a method with controlled/limited recursive logic.
     * Passed argument never will be greater than 999.
     * Recursivity allow us to use the same logic to carry out subsequent operations with the same logic.
     * The solution IS scalable because a wider range of numbers will not require changes 
     * in the implementation, only in data from arrays (qualifiers array) Data in this array could be 
     * stored in static configuration and not in code).
     * An alternative iterative solution is always possible. The best solution should be 
     * adapted to several factors such as Concurrency, Parallelism conditions, CPU architecture, etc.
     * 
     * @param  i  the number to be calculated as a cardinal/ordinal
     * @return    The String with the cardinal/ordinal
     */
    private String calculate(int i) {
        //Units: First, check if the number is in the range 0-19 (instance var 'units').
        if (i < 20) {
            //Directly returns the value in the array
            return units[i];
        }
        //Tens: If not, check if the number is below 100 (instance var 'tens').
        //Recursivity starts here, to write module units.
        if (i < 100) {
            return tens[i / 10] + ((i % 10 > 0) ? " " + calculate(i % 10) : "");
        }
        return units[i / 100] + " " + hundred + ((i % 100 > 0) ? " " + conjunction + " " + calculate(i % 100) : "");
    }


    /**
     * private method to return the formatted number.
     * @param  i  the number to be formatted
     * @return    The String with the formatted number
     */
    private String customFormat(double value) {
        DecimalFormat myFormatter = new DecimalFormat(decimalFormat);

        return myFormatter.format(value);
    }
}
